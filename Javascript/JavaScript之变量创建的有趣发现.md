---
title: JavaScript之变量创建的有趣发现
date: 2019-04-01 20:30:30
categories: 学习笔记
tags: [JavaScript]
---

近日在看面试题的时候发现了变量创建的另一种方法，即不用关键字（var、let、const）创建变量，而是直接赋值，如
```
    a=1;
    console.log(a);
```
开始第一眼看见这个代码认为会报错，因为a未声明，但是神奇的是并没有报错，并且a的值正常输出为1.

我开始猜想**a = 1**等价于**this.a = 1**，在上面的情况中，this指向全局对象window，所以a会作为属性加入window对象的属性里面

为了验证，我又测试了下面的代码
```
    var obj={
        f : function bar() {
            a = 1;
            }
    };
    obj.f();
    console.log(obj.a); //undefined
    console.log(window.a); // 1
```

如果正如我之前所想，即**a = 1**等价于**this.a = 1**，那么这里this指向obj，a就应该加入到obj的属性中，即obj.a应该为1。但是，结果显示obj.a为undefined, window.a为1。说明我之前的猜想是错误的。

最后，我得出的结论是
**不用关键字直接赋值产生的变量（此变量未声明过）无论在什么场景下都会加入到全局对象window的属性中。**

补充：
（通过看<<你不知道的JavaScript（上）>>作用域篇得到的启发）
如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。
相较之下，**当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。**
“不，这个变量之前并不存在，但是我很热心地帮你创建了一个。”
ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上 有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。

